/ assignment1.legv8asm
/ Oliver Strauss (ols756@iastate.edu)
/ CS321 Fall 2025 - Programming Assignment 1
/ Stoopid Sort implementation

B main

main:
    SUBI SP, SP, #192        // reserve space for saves + array (aligned)

    STUR X30, [SP, #0]       // save return addr if any
    STUR X19, [SP, #8]       // save old X19
    STUR X20, [SP, #16]      // save old X20

    // Set array base inside our frame 
    ADD X19, SP, XZR         // X19 = SP
    ADDI X19, X19, #32       // X19 = &array_region
    ADDI X20, XZR, #10       // X20 = size = 15

    // prepare args and call fill
    ADD X0, X19, XZR         // X0 = array base
    ADD X1, X20, XZR         // X1 = n
    BL fill

    // prepare to call print_loop: initialize index register X21
    ADD X21, XZR, XZR    // X21 = 0          // i = 0  <--- was missing

    ADD X0, X19, XZR         // X0 = array base (not used by print_loop in this version; kept for clarity)
    ADD X1, X20, XZR         // X1 = n
    BL print_loop

    ADD X0, X19, XZR     // base address of array
    ADDI X1, XZR, #3     // n = 3
    ADDI X2, XZR, #7     // m = 7
    BL max_index         // call
    PRNT X0

    // restore saved registers and deallocate main frame BEFORE HALT
    LDUR X30, [SP, #0]
    LDUR X19, [SP, #8]
    LDUR X20, [SP, #16]
    ADDI SP, SP, #192
    HALT



// print_loop: prints a[0..n-1]
// expects:
// X19 = base address (we set that in main)
// X20 = size
// X21 = index (initialized to 0 before BL)

print_loop:
    SUBS XZR, X21, X20
    B.GE print_done          // while (i < n)

    LSL X22, X21, #3         // multiply by 8 bytes (each int)
    ADD X23, X19, X22       // address of a[i]
    LDUR X24, [X23, #0]     // X24 = a[i]
    PRNT X24                // print the value

    ADDI X21, X21, #1       // i++
    B print_loop

print_done:
    BR LR                   // return to caller (main) which will restore stack & HALT


   //fill: unchanged logic, expects X0=array, X1=n

fill:
    // Save registers
    SUBI SP, SP, #64
    STUR X30, [SP, #0]
    STUR X19, [SP, #8]
    STUR X20, [SP, #16]
    STUR X21, [SP, #24]
    STUR X22, [SP, #32]
    STUR X23, [SP, #40]

    ADD X19, X0, XZR      // X19 = base address of array a
    ADD X20, X1, XZR      // X20 = n
    SUBI X21, X20, #1     // X21 = i = n - 1

fill_loop:
    SUBS XZR, X21, XZR
    B.LT fill_done     // while (i >= 0)
   

    SUB X22, X20, X21     // X22 = n - i
    SUBI X22, X22, #1     // X22 = n - i - 1  (index)
    LSL X23, X22, #3      // multiply by 8 (64-bit integers)
    ADD X23, X19, X23     // X23 = &a[n - i - 1]

    STUR X21, [X23, #0]   // a[n - i - 1] = i

    SUBI X21, X21, #1     // i--
    B fill_loop

fill_done:
    // Restore registers
    LDUR X30, [SP, #0]
    LDUR X19, [SP, #8]
    LDUR X20, [SP, #16]
    LDUR X21, [SP, #24]
    LDUR X22, [SP, #32]
    LDUR X23, [SP, #40]
    ADDI SP, SP, #64
    BR LR


max_index:
    SUBI SP, SP, #32
    STUR X30, [SP, #0]
    STUR X9,  [SP, #8]
    STUR X10, [SP, #16]

    / Load a[n] into X9
    LSL X9, X1, #3
    ADD X9, X0, X9
    LDUR X9, [X9, #0]

    / Load a[m] into X10
    LSL X10, X2, #3
    ADD X10, X0, X10
    LDUR X10, [X10, #0]

    / Compare a[n] and a[m]
    SUBS XZR, X9, X10

B.LT returnM          / if a[n] < a[m], return a[m]

/ Otherwise, return a[n]
ADD X0, X1 ,XZR
B max_done

returnM:
    ADD X0, X2,XZR


max_done:
    // Epilogue - restore registers
    LDUR X30, [SP, #0]
    LDUR X9,  [SP, #8]
    LDUR X10, [SP, #16]
    ADDI SP, SP, #32
    BR LR