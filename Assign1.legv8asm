/ assignment1.legv8asm
/ Oliver Strauss (ols756@iastate.edu)
/ Annelie Erickson (aericks@iastate.edu)
/ CS321 Fall 2025 - Programming Assignment 1
/ Stoopid Sort implementation (fixed/debugged)

B main

//--------------------------------------------------
// MAIN
//--------------------------------------------------
main:
    SUBI SP, SP, #192            // reserve stack frame
    STUR X30, [SP, #0]
    STUR X19, [SP, #8]
    STUR X20, [SP, #16]

    // Set array base and size
    ADDI X19, SP, #32            // X19 = &array_region (array base)
    ADDI X20, XZR, #10           // X20 = size = 10

    //----------------------------------------
    // Fill array (descending values)
    //----------------------------------------
    ADD X0, X19, XZR             // X0 = array base
    ADD X1, X20, XZR             // X1 = n
    BL fill


    //----------------------------------------
    // Print array before sort
    //----------------------------------------
    ADD X0, X19, XZR             // X0 = array base
    ADD X1, X20, XZR             // X1 = n
    ADDI X2, XZR, #0             // X2 = i = 0
    BL print_loop

    // ADD X0, X19, XZR             // base
    // ADDI X1, XZR, #0             // start = 0
    // ADD X2, X20, XZR             // size = n
    // BL find_largest

    // stoopid_sort
    ADD X0, X19, XZR // a
    ADD X1, X20, XZR // size
    BL stoopid_sort

    // print array after sort
    ADD X0, X19, XZR // base
    ADD X1, X20, XZR  // a
    ADD X2, XZR, XZR // i = 0
    BL print_loop



    //----------------------------------------
    // Swap for test 
    //----------------------------------------
    // ADD X0, X19, XZR             // X0 = array base
    // ADDI X1, XZR, #0             // X1 = n
    // ADDI X2, XZR, #5             // X2 = i = 0
    // BL swap

      //----------------------------------------
    // Print array before swap
    //----------------------------------------
   // ADD X0, X19, XZR             // X0 = array base
    //ADD X1, X20, XZR             // X1 = n
  //  ADDI X2, XZR, #0             // X2 = i = 0
    //BL print_loop


  




   // ADD X0, X19, XZR
   // ADD X1, X20, XZR
    //BL is_sorted
  //  PRNT X0                      // prints 0 if sorted, 1 if not

    
   // ADD X0, X19, XZR             // base
   // ADDI X1, XZR, #0             // start = 0
   // ADD X2, X20, XZR             // size = n
   // BL find_largest
   // PRNT X0

    //----------------------------------------
    // Restore and HALT
    //----------------------------------------
    LDUR X30, [SP, #0]
    LDUR X19, [SP, #8]
    LDUR X20, [SP, #16]
    ADDI SP, SP, #192
    HALT


//--------------------------------------------------
// PRINT_LOOP
// Expects: X0 = base, X1 = n, X2 = i (start index)
//--------------------------------------------------
print_loop:
    SUBI SP, SP, #32
    STUR X30, [SP, #0]
    STUR X3,  [SP, #8]
    STUR X4,  [SP, #16]

pl_loop:
    // while (i < n)
    SUBS XZR, X2, X1
    B.GE pl_done

    LSL X3, X2, #3            // offset = i * 8
    ADD X3, X0, X3            // address = base + offset
    LDUR X4, [X3, #0]         // load a[i]
    PRNT X4

    ADDI X2, X2, #1           // i++
    B pl_loop

pl_done:
    LDUR X30, [SP, #0]
    LDUR X3,  [SP, #8]
    LDUR X4,  [SP, #16]
    ADDI SP, SP, #32
    BR LR


//--------------------------------------------------
// IS_SORTED
// Expects: X0 = base Address , X1 = n
// Returns: X0 = 0 if sorted (non-decreasing), 1 if not sorted
//--------------------------------------------------
is_sorted:
    SUBI SP, SP, #40
    STUR X30, [SP, #0]
    STUR X3,  [SP, #8]
    STUR X4,  [SP, #16]
    STUR X5,  [SP, #24]

    ADDI X2, XZR, #1          // i = 1

sorted_loop:
    // while (i < n)
    SUBS XZR, X2, X1
    B.GE done

    // load a[i]
    LSL X3, X2, #3            // offset = i * 8
    ADD X3, X0, X3            // address = base + offset
    LDUR X4, [X3, #0]         // X4 = a[i]

    // load a[i-1]
    SUBI X5, X2, #1           // X5 = i - 1
    LSL  X5, X5, #3           // X5 = (i - 1) * 8
    ADD  X5, X0, X5           // X5 = address of a[i - 1]
    LDUR X6, [X5, #0]         // X6 = a[i - 1]

    // If a[i] < a[i-1] -> not sorted (strictly less)
    SUBS XZR, X4, X6
    B.LT not_sorted

    ADDI X2, X2, #1           // i++
    B sorted_loop

not_sorted:
    ADDI X0, XZR, #1          // return 1 (not sorted)
    B exit_is_sorted

done:
    ADDI X0, XZR, #0          // return 0 (sorted)

exit_is_sorted:
    LDUR X30, [SP, #0]
    LDUR X3,  [SP, #8]
    LDUR X4,  [SP, #16]
    LDUR X5,  [SP, #24]
    ADDI SP, SP, #40
    BR LR



//--------------------------------------------------
// SWAP
// Expects: X0 = base, X1 = i, X2 = j
//--------------------------------------------------
swap:
    SUBI SP, SP, #48
    STUR X30, [SP, #0]
    STUR X9,  [SP, #8]
    STUR X10, [SP, #16]
    STUR X11, [SP, #24]
    STUR X12, [SP, #32]

    LSL X9, X1, #3             // &a[i]
    ADD X9, X0, X9
    LDUR X10, [X9, #0]         // X10 = a[i]

    LSL X11, X2, #3            // &a[j]
    ADD X11, X0, X11
    LDUR X12, [X11, #0]        // X12 = a[j]

    STUR X12, [X9, #0]         // a[i] = a[j]
    STUR X10, [X11, #0]        // a[j] = old a[i]

    LDUR X30, [SP, #0]
    LDUR X9,  [SP, #8]
    LDUR X10, [SP, #16]
    LDUR X11, [SP, #24]
    LDUR X12, [SP, #32]
    ADDI SP, SP, #48
    BR LR


//--------------------------------------------------
// FILL
// Expects: X0 = base, X1 = n
// Fills array in descending order: a[0] = n-1, a[1] = n-2, ...
//--------------------------------------------------
fill:
    SUBI SP, SP, #64
    STUR X30, [SP, #0]
    STUR X19, [SP, #8]
    STUR X20, [SP, #16]
    STUR X21, [SP, #24]
    STUR X22, [SP, #32]
    STUR X23, [SP, #40]

    ADD X19, X0, XZR           // base
    ADD X20, X1, XZR           // n
    SUBI X21, X20, #1          // i = n - 1

fill_loop:
    // while (i >= 0)
    SUBS XZR, X21, XZR
    B.LT fill_done

    SUB X22, X20, X21          // X22 = n - i
    SUBI X22, X22, #1          // X22 = n - i - 1
    LSL X23, X22, #3          // offset
    ADD X23, X19, X23          // &a[n - i - 1]

    STUR X21, [X23, #0]        // a[n - i - 1] = i

    SUBI X21, X21, #1
    B fill_loop

fill_done:
    LDUR X30, [SP, #0]
    LDUR X19, [SP, #8]
    LDUR X20, [SP, #16]
    LDUR X21, [SP, #24]
    LDUR X22, [SP, #32]
    LDUR X23, [SP, #40]
    ADDI SP, SP, #64
    BR LR


//--------------------------------------------------
// MAX_INDEX
// Expects: X0 = base, X1 = i, X2 = j
// Returns: X0 = index of larger element (between indices i and j)
//--------------------------------------------------
max_index:
    SUBI SP, SP, #32
    STUR X30, [SP, #0]
    STUR X9,  [SP, #8]
    STUR X10, [SP, #16]

    // load a[i]
    LSL X9, X1, #3
    ADD X9, X0, X9
    LDUR X9, [X9, #0]

    // load a[j]
    LSL X10, X2, #3
    ADD X10, X0, X10
    LDUR X10, [X10, #0]

    // compare a[i] and a[j]
    SUBS XZR, X9, X10
    B.LT returnM
    ADD X0, X1, XZR
    B max_done

returnM:
    ADD X0, X2, XZR

max_done:
    LDUR X30, [SP, #0]
    LDUR X9,  [SP, #8]
    LDUR X10, [SP, #16]
    ADDI SP, SP, #32
    BR LR


//--------------------------------------------------
// FIND_LARGEST (with debug prints)
//--------------------------------------------------
find_largest:
    SUBI SP, SP, #64
    STUR X30, [SP, #0]
    STUR X19, [SP, #8]
    STUR X20, [SP, #16]
    STUR X21, [SP, #24]
    STUR X22, [SP, #32]
    STUR X23, [SP, #40]

    ADDI X27, XZR, #1
    // Base case: if size == 1 â†’ return start
    SUBS XZR, X2, X27
    B.NE fl_recurse
    ADD X0, X1, XZR
    // --- Debug print ---
    PRNT X0          // prints the index returned in base case
    B fl_done

fl_recurse:
    // left_size = size / 2
    LSR X19, X2, #1          // X19 = size / 2
    ADD X9, X0, XZR          // base
    ADD X10, X1, XZR         // start
    ADD X11, X2, XZR         // size

    // --- Debug ---
    // Print entry info: start, size
    PRNT X10                 // print current start
    PRNT X11                 // print current size

    // --- Call left half ---
    ADD X0, X9, XZR
    ADD X1, X10, XZR
    ADD X2, X19, XZR
    BL find_largest
    ADD X20, X0, XZR         // leftIndex
    PRNT X20                 // debug: print leftIndex result

    // --- Call right half ---
    ADD X1, X10, X19         // start + left_size
    ADDI X23, X11, #1
    LSR X23, X23, #1         // (size+1)/2
    ADD X0, X9, XZR
    ADD X2, X23, XZR
    BL find_largest
    ADD X21, X0, XZR         // rightIndex (relative)
    ADD X21, X21, X10        // make absolute
    PRNT X21                 // debug: print rightIndex result

    // --- Compare left vs right ---
    ADD X0, X9, XZR
    ADD X1, X20, XZR
    ADD X2, X21, XZR
    BL max_index
    PRNT X0                  // debug: print final chosen index

fl_done:
    LDUR X30, [SP, #0]
    LDUR X19, [SP, #8]
    LDUR X20, [SP, #16]
    LDUR X21, [SP, #24]
    LDUR X22, [SP, #32]
    LDUR X23, [SP, #40]
    ADDI SP, SP, #64
    BR LR



//--------------------------------------------------
// STOOPID_SORT
// Expects: X0 = base (a), X1 = size
//--------------------------------------------------
stoopid_sort:
    SUBI SP, SP, #64
    STUR X30, [SP, #0]
    STUR X19, [SP, #8]
    STUR X20, [SP, #16]
    STUR X21, [SP, #24]
    STUR X22, [SP, #32]
    STUR X23, [SP, #40]

    ADD X19, X0, XZR // X19 = base a
    ADD X20, X1, XZR // X20 = size
    ADDI X21, XZR, #0 // X21 = i = 0

ss_loop:
    // while (i < size - i)
    SUBI X23, X20, #1
    SUBS XZR, X21, X23 // X23 = size - 1
    B.GE ss_done

    // n = find_largest(a, 0, size - 1)
    SUB X23, X20, X21 // X23 = size - 1
    ADD X0, X19, XZR // arg0 = a
    ADDI X1, XZR, #0 // arg1 = 0
    ADD X2, X23, XZR // arg2 = size - 1
    BL find_largest
    ADD X22, X0, XZR // X22 = n (return value)

    // swap(a, n, size - i - 1)
    SUB X23, X20, X21 // X23 = size - i
    SUBI X23, X23, #1 // X23 = size - i - 1
    ADD X0, X19, XZR // arg0 = a
    ADD X1, X22, XZR // arg1 = n
    ADD X2, X23, XZR // arg2 = size - i - 1 
    BL swap 

    // i++
    ADDI X21, X21, #1
    B ss_loop

ss_done:
LDUR X30, [SP, #0]
    LDUR X19, [SP, #8]
    LDUR X20, [SP, #16]
    LDUR X21, [SP, #24]
    LDUR X22, [SP, #32]
    LDUR X23, [SP, #40]
    ADDI SP, SP, #64
    BR LR
