/ assignment1.legv8asm
/ Oliver Strauss (ols756@iastate.edu)
/ CS321 Fall 2025 - Programming Assignment 1
/ Stoopid Sort implementation

B main

main:
    SUBI SP, SP, #192        // reserve space for saves + array (aligned)

    STUR X30, [SP, #0]       // save return addr if any
    STUR X19, [SP, #8]       // save old X19
    STUR X20, [SP, #16]      // save old X20

    // Set array base inside our frame 
    ADD X19, SP, XZR         // X19 = SP
    ADDI X19, X19, #32       // X19 = &array_region
    ADDI X20, XZR, #10       // X20 = size = 15

    // prepare args and call fill
    ADD X0, X19, XZR         // X0 = array base
    ADD X1, X20, XZR         // X1 = n
    BL fill

    // prepare to call print_loop: initialize index register X21
    ADD X21, XZR, XZR    // X21 = 0          

    //ADD X0, X19, XZR         // X0 = array base 
    //ADD X1, X20, XZR         // X1 = n
    //ADD X21, XZR, XZR
   // BL print_loop

   // ADD X0, X19, XZR     // base address of array
   // ADDI X1, XZR, #3     // n = 3
   // ADDI X2, XZR, #7     // m = 7
  //  BL max_index         // call
   // PRNT X0

    ADD X0, X19, XZR     // base address of array
    ADDI X1, XZR, #0    // i =0
    ADDI X2, XZR, #1    // j = 1
    BL swap         // call


    ADD X21, XZR, XZR    // X21 = 0
    ADD X0, X19, XZR    
    ADD X1, X20,XZR
    BL print_loop




    // restore saved registers and deallocate main frame BEFORE HALT
    LDUR X30, [SP, #0]
    LDUR X19, [SP, #8]
    LDUR X20, [SP, #16]
    ADDI SP, SP, #192
    HALT





// expects:
// X19 = base address 
// X20 = size
// X21 = index (initialized to 0 before BL)

print_loop:
    SUBI SP, SP, #32
    STUR X30, [SP, #0]
    STUR X2,  [SP, #8]     // save temp reg X2 if needed
    STUR X3,  [SP, #16]

pl_loop:
    SUBS XZR, X2, X1       // set flags for i - n
    B.GE pl_done

    LSL X3, X2, #3         // offset = i * 8
    ADD X3, X0, X3         // address = base + offset
    LDUR X4, [X3, #0]      // load a[i]
    PRNT X4

    ADDI X2, X2, #1        // i++
    B pl_loop

pl_done:
    LDUR X30, [SP, #0]
    LDUR X2,  [SP, #8]
    LDUR X3,  [SP, #16]
    ADDI SP, SP, #32
    BR LR



//expects
//X0 = address of a
//X1 = i
//X2 = j
swap:
    SUBI SP, SP, #32        // make stack space
    STUR X30, [SP, #0]      // save return address
    STUR X9,  [SP, #8]      // save temp registers
    STUR X10, [SP, #16]

    LSL X9, X1,#3 // temp = i*8
    ADD X9, X0, X9 // Add adress to temp X9 = a[i]
    LDUR X10 ,[X9, #0] // X10 = temp 

    LSL X11, X2,#3 // temp = j*8
    ADD X11, X0, X11 // Add adress to temp
    LDUR X12,[ X11, #0] // X12 = a[j]
    
    STUR X12,[X9,#0] //a[i] = a[j]
    STUR X10, [X11, #0] //a[j] = temp

    LDUR X30, [SP, #0]
    LDUR X9,  [SP, #8]
    LDUR X10, [SP, #16]
    ADDI SP, SP, #32
    BR LR







//fill: unchanged logic, expects X0=array, X1=n

fill:
    // Save registers
    SUBI SP, SP, #64
    STUR X30, [SP, #0]
    STUR X19, [SP, #8]
    STUR X20, [SP, #16]
    STUR X21, [SP, #24]
    STUR X22, [SP, #32]
    STUR X23, [SP, #40] 

    ADD X19, X0, XZR      // X19 = base address of array a
    ADD X20, X1, XZR      // X20 = n
    SUBI X21, X20, #1     // X21 = i = n - 1

fill_loop:
    SUBS XZR, X21, XZR
    B.LT fill_done     // while (i >= 0)
   

    SUB X22, X20, X21     // X22 = n - i
    SUBI X22, X22, #1     // X22 = n - i - 1  (index)
    LSL X23, X22, #3      // multiply by 8 (64-bit integers)
    ADD X23, X19, X23     // X23 = &a[n - i - 1]

    STUR X21, [X23, #0]   // a[n - i - 1] = i

    SUBI X21, X21, #1     // i--
    B fill_loop

fill_done:
    // Restore registers
    LDUR X30, [SP, #0]
    LDUR X19, [SP, #8]
    LDUR X20, [SP, #16]
    LDUR X21, [SP, #24]
    LDUR X22, [SP, #32]
    LDUR X23, [SP, #40]
    ADDI SP, SP, #64
    BR LR


max_index:
    SUBI SP, SP, #32
    STUR X30, [SP, #0]
    STUR X9,  [SP, #8]
    STUR X10, [SP, #16]

    / Load a[n] into X9
    LSL X9, X1, #3
    ADD X9, X0, X9
    LDUR X9, [X9, #0]

    / Load a[m] into X10
    LSL X10, X2, #3
    ADD X10, X0, X10
    LDUR X10, [X10, #0]

    / Compare a[n] and a[m]
    SUBS XZR, X9, X10

B.LT returnM          / if a[n] < a[m], return a[m]

/ Otherwise, return a[n]
ADD X0, X1 ,XZR
B max_done

returnM:
    ADD X0, X2,XZR


max_done:
    // Epilogue - restore registers
    LDUR X30, [SP, #0]
    LDUR X9,  [SP, #8]
    LDUR X10, [SP, #16]
    ADDI SP, SP, #32
    BR LR